import { mkdirSync, readFileSync, rmSync, writeFileSync } from 'fs'
import { basename, dirname, extname, join, relative } from 'path'
import { getStoryTitle, serverRequire } from 'storybook/internal/common'
import { loadCsf, type StaticStory } from 'storybook/internal/csf-tools'
import type { StoriesEntry, StorybookConfig } from 'storybook/internal/types'
import { findStoriesToTest as findCsfsToTest } from './find-stories-to-test'

export function generateTests ({
  projectRoot,
  storybookConfigDirectory,
  testDirectory
}: {
  projectRoot: string;
  storybookConfigDirectory: string;
  testDirectory: string;
}) {
  const csfPatterns = getCsfPatterns(storybookConfigDirectory)

  rmSync(testDirectory, { recursive: true, force: true })
  mkdirSync(testDirectory, { recursive: true })

  const csfsToTest = findCsfsToTest(
    csfPatterns,
    { projectRoot, storybookConfigDirectory }
  )

  for (const csfToTest of csfsToTest) {
    const code = readFileSync(csfToTest, { encoding: 'utf-8' })
    const storiesInCsf = parseCsf(code, csfToTest, csfPatterns, storybookConfigDirectory)
    const jestTest = generateJestTest(csfToTest, storiesInCsf)

    // make spec path unique by mirroring the CSF relative path under .detox-tests
    const relCsfPath = relative(projectRoot, csfToTest)
    const outDir = join(testDirectory, dirname(relCsfPath))
    mkdirSync(outDir, { recursive: true })

    const outFile = join(outDir, `${basename(csfToTest, extname(csfToTest))}.spec.js`)
    writeFileSync(outFile, jestTest)
  }

  return { csfsToTest }
}

function getCsfPatterns (configDir: string) {
  // Typescript config is not supported.
  const mainConfig = serverRequire(join(configDir, 'main')) as Partial<StorybookConfig> | undefined
  if (!mainConfig) {
    throw new Error(`Could not load main.js in ${configDir}.`)
  }
  if (!mainConfig.stories || mainConfig.stories.length === 0) {
    throw new Error(`Could not find stories in main.js in "${configDir}".`)
  }
  return mainConfig.stories as StoriesEntry[]
}

function parseCsf (code: string, csfFilePath: string, csfPatterns: StoriesEntry[], storybookConfigDirectory: string) {
  const csf = loadCsf(code, {
    fileName: csfFilePath,
    makeTitle (userTitle) {
      return getStoryTitle({
        storyFilePath: csfFilePath,
        configDir: storybookConfigDirectory,
        stories: csfPatterns,
        userTitle
      }) || 'unknown'
    }
  })
  const { _stories } = csf.parse()
  return _stories
}

function generateJestTest (csfFilePath: string, stories: Record<string, StaticStory>) {
  return `
    // This file is auto-generated by storybook-detox-test-runner.
    const story = require('${csfFilePath}')
    const channel = require('${join(__dirname, '..', 'channel.js')}')
    const detox = require('detox')

    // STORYBOOK_LAUNCH_RETRIES controls how many retries we perform
    // *after* the first failed launch, for transient Detox disconnect errors.
    // 0  => no retries
    // 1  => one retry (total 2 attempts), etc.
    const _rawRetries = process.env.STORYBOOK_LAUNCH_RETRIES
    const _parsedRetries = _rawRetries != null ? Number(_rawRetries) : 1
    const MAX_LAUNCH_RETRIES =
      Number.isFinite(_parsedRetries) && _parsedRetries >= 0 ? _parsedRetries : 1

    function isDetoxDisconnectedError(error) {
      if (!error) return false
      const msg = String(error.message || error)

      // Be tolerant to minor text variations across Detox versions.
      return (
        msg.includes('unexpectedly disconnected from Detox server') ||
        msg.includes("Detox can't seem to connect to the test app") ||
        msg.includes('The pending request #-1000 ("isReady") has been rejected')
      )
    }

    const _sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms))

    async function launchAppWithRetry(config) {
      const baseConfig = (config && typeof config === 'object') ? { ...config } : {}
      const platform = device.getPlatform()
      let attempt = 0

      // attempt === 0: first launch attempt
      // 1..MAX_LAUNCH_RETRIES: retry attempts for transient Detox disconnect errors
      while (true) {
        try {
          const effectiveConfig =
            attempt === 0 || platform !== 'android'
              ? baseConfig
              : (
                  // On Android retries, force newInstance: true only if the user
                  // did not specify newInstance explicitly in the launch config.
                  baseConfig.newInstance === undefined
                    ? { ...baseConfig, newInstance: true }
                    : baseConfig
                )

          return await device.launchApp(effectiveConfig)
        } catch (err) {
          if (!isDetoxDisconnectedError(err) || attempt >= MAX_LAUNCH_RETRIES) {
            throw err
          }

          attempt += 1
          // Small delay before retrying helps Detox / emulator stabilize after a crash.
          // eslint-disable-next-line no-console
          console.warn(
            \`[storybook-detox] launchApp retry attempt=\${attempt}/\${MAX_LAUNCH_RETRIES} after disconnect\`,
          )
          await _sleep(1000)
        }
      }
    }

    beforeAll(async () => {
      await channel.routeFromDeviceToServer()
    })

    function testOrSkip (onlyOnOperatingSystems) {
      if (onlyOnOperatingSystems === undefined) {
        return test
      }
      return onlyOnOperatingSystems.includes(device.getPlatform()) ? test : test.skip
    }

    ${Object.entries(stories)
        .map(([variableName, story]) => generateTestForStory(variableName, story))
        .join('')}`
}

function generateTestForStory (variableName: string, story: StaticStory) {
  return `
    testOrSkip(story.${variableName}.detox?.onlyOnOperatingSystems)('${story.name}', async function () {
      console.log('[storybook-detox][phase]', '${story.id}', 'launchApp:start')
      await launchAppWithRetry(story.${variableName}.detox?.launch)
      console.log('[storybook-detox][phase]', '${story.id}', 'launchApp:done')

      console.log('[storybook-detox][phase]', '${story.id}', 'changeStory:start')
      await channel.changeStory('${story.id}')
      console.log('[storybook-detox][phase]', '${story.id}', 'changeStory:done')

      console.log('[storybook-detox][phase]', '${story.id}', 'play:start')
      await story.${variableName}.play?.({ detox })
      console.log('[storybook-detox][phase]', '${story.id}', 'play:done')
    })\n\n`
}
